### Python性能分析及优化

#### 1.GIL — Global Interpreter LOck(全局解释器锁，Cpython解释器)

如Java有虚拟机，Python也有"虚拟机"，但其实它叫解释器。
Python解释器将源码转换为字节码，然后再由解释器来执行这些字节码。：源代码--->字节码--->解释执行
Python默认解释器时Cpython，他们的内存管理不是线程安全的，为保护多线程之间数据完整性和状态同步，Cpython使用锁机制，于是有了GIL这把超级大锁，使得在任意时刻只有一个线程在解释器中运行。
GIL是一个防止本机多个线程同时执行Python字节码的互斥锁。锁的是解释器（Cpython）。
只有当线程获取到全局解释器锁后才能运行，而全局解释器锁只有一个，因此即使在多核的情况下也只能发挥出单核的功能。

**多线程环境中，python解释器按照以下方式执行：**

1.设置GIL
2.切换到一个线程去执行
2.运行代码，这里有两种机制：
    - 指定数量的字节码指令（100个，有个ticks在计数）
    - 固定时间15ms线程主动让出控制
3.线程进入阻塞状态
4.释放GIL
5.再次重复以上步骤

GIL缺点：
    限制了程序的多核执行，无法发挥多核机器的优势
    cpu密集型程序难以利用多核执行任务

GIL会根据执行的字节码行数和时间片来释放GIL，在遇到IO操作的时候会主动释放以给其他线程，其他线程之间竞争Gil锁。

#### 2.规避GIL的影响
1. 区分IO密集型任务和CPU密集型任务，CPU密集型任务采用多进程、进程池的方式。IO密集型由于影响很小仍可以采用多线程执行任务。
2. 用其他解释器，如Jpython、IronPython，但这样失去了利用社区众多C语言模块有用特性的机会。

#### 3.有了GIL还有关注线程安全？
是的，在Python中原子操作是线程安全的（因为Python解释器只有在一个机器指令完成后另一个机器指令未开始前进行线程切换）。但是非原子操作就需要我们自己来保证线程安全。
原子操作：被编译为单个字节码指令的操作，要么执行成功，要么执行失败并回退已执行的操作。使用dis包可以查看。
Python中相当大一部分操作都是原子的，即使像字典和类成员赋值这样的操作也是原子的。多条语句、运算符"+="等是非原子操作，例如"i=j+1"这样的单挑语句也不是原子操作。

在多线程任务中，非原子操作我们可以使用threading.Lock()来保证线程安全：

```python
import threading

#创建锁
mutex = threading.Lock()
#锁定
mutex.acquire()
#释放
mutex.release()
```
示例：
```python
import threading

lock = threading.Lock()
l = []

def test1(n):
    lock.acquire()
    l.append(n)
    print(l)
    lock.release()

def test(n):
    l.append(n)
    print(l)

def main():
    for i in range(0, 10):
        th = threading.Thread(target=test, args=(i,))
        th.start()
if __name__=="__main__":
    main()

```
结果：
```
[0]
[0, 1]
[0, 1, 2]
[0, 1, 2, 3]
[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4, 5]
[0, 1, 2, 3, 4, 5, 6]
[0, 1, 2, 3, 4, 5, 6, 7]
[0, 1, 2, 3, 4, 5, 6, 7, 8]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

#### 4.提高Python程序性能的七个小技巧
1. 使用局部变量
尽可能使用局部变量替代全局变量，可以是程序易于维护并且有助于提高性能节约成本。

2. 减少函数调用的数量
当需要确定对象类型时，使用isinstance()方法最好，id()次之，type()最差。
为了避免重复计算，不要把重复操作作为参数放入循环中。
使用模块X中的函数或者对象Y时，应该用from X import Y，而不是import X; X.Y。因为，当使用Y时，可以减少一次查询（解析器不必先找到模块X，然后在模块X的字典中查找Y）。

3. 使用映射来替换条件搜索
映射（例如dict，等等）的搜索速度比条件语句（例如if，等等）快很多。在Python中没有select-case语句。

4. 直接迭代序列元素
对于序列（str, list, tuple, 等等），直接迭代序列元素比迭代元素索引要快。

5. 用生成器表达式替换列表解析
列表解析生成整个列表，会对大量数据的迭代产生负面作用。而生成器表达式不会。生成器表达式不会创建一个列表，相反返回一个生成器，在需要的时候生成具体值（延迟的），这种方式对内存友好。

6. 先编译后调用
当使用函数eval()和exec()来执行代码时，最好调用代码对象（通过compile()函数预先编译成字节码）而不是直接调用str，这样可以避免重复编译过程多次和提高程序的性能。
正则表达式模式匹配是类似的。 在执行比较和匹配之前，最好将正则表达式模式编译为正则表达式对象（通过re.complie()函数）

7. 模块编程的习惯
模块中最高级别的Python语句（无缩进代码）将在导入模块时执行（是否真的需要执行）。 因此，您应该尝试将模块的所有功能代码放入函数中（与主程序相关的功能代码也可以放入main()函数，主程序本身调用main()函数）。
测试代码可以写在模块的main()函数中。 将在主程序中检测__name__的值。 如果是"__main__"（表示模块是直接执行的），则调用main()函数进行测试; 如果它是模块的名称（表示模块被调用），则不会执行测试。

#### 5.如何剖析程序性能？
各种profile工具，如内置的profile/cprofile等，其他的如uber开源的pyflame

#### 6.从哪些方面优化服务端性能？ Web应用一般语言不是性能瓶颈
1.数据结构与算法的优化
2.数据库层：索引优化，消除慢查询，批量操作以减少IO，其他Nosql
3.网络IO：批量操作，pipline操作减少IO
4.缓存：客户端缓存，使用内存数据库redis等
5.异步：asyncio,celery
6.并发：gevent/多线程

