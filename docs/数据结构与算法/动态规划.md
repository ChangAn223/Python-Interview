
### 动态规划

#### 1. 使用条件：

**最优子结构性质：** 如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构

**无后效性：** 即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。

**子问题重叠性：** 即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）


#### 2. 动规解题的一般思路

动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。
动态规划的设计都有着一定的模式，一般要经历以下几个步骤。

    初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态

**解题步骤：**

    (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。

    (2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。

    (3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。

    (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。

一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。

**最简化步骤：**

    （1）确定状态转移方程

    （2）找到边界条件

    （3）递归的定义最优解。

    （4）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值。根据计算最优值时得到的信息，构造问题的最优解

#### 最大子数组问题

一个数组，求他的一个子数组，这个子数组中的所有值的和是最大。

例子：数组 arr = arr = [6, -1, 8, -4, -6, 3, 2, -2, 5]，最大连续子序列和为13。即为：6,-1,8

**状态转移方程：**

创建一个数组res，长度为原数组长度，不同位置数字a[i]代表0...i上最大连续子序列和，a[0]=arr[0]设置一个最大值max，初始值为数组中的第一个数字。当进来一个新的数字arr[i+1]时，判断到他前面数字子序列和a[i]+arr[i+1]跟arr[i+1]哪个大，前者大就保留前者，后者大就说明前面连续数字加起来都不如后者一个新进来的数字大，前面数字就可以舍弃，从arr[i+1]开始，每次比较完都跟max比较一下，最后的max就是最大值。

      |—> opt(i-1) + arr[i]   (选择当前元素)
  opt(i)= |
      |—> arr[i]  (当前元素比前几个元素和还大，所以放弃前面的)

**边界条件：**

  (1) i = 0 此时数组从尾到头走完了

完整代码：
```python
arr = [6, -1, 8, -4, -6, 3, 2, -2, 5]

def dp_opt(arr):
    # 记录数组
    res = [0 for i in range(len(arr))]
    # 初始化数组
    res[0] = arr[0]
    # 记录最大值的变量
    max_sum = res[0]
    # 开始循环
    for i in range(1, len(arr)):
        a = res[i - 1] + arr[i]
        b = arr[i]
        res[i] = max(a, b)
        max_sum = max_sum if max_sum >res[i] else res[i]
    return max_sum

print(dp_opt(arr))
```
结果为13，说明正确。


#### 0 1 背包问题

在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为V1,V2……Vn（Vi为整数），求背包能够容纳的最大价值。

例子：物品体积数组：w = [3,5,2,7,4]，物品价值数组：v = [2,4,1,6,5]，背包容量：s = 10

**1.找出状态转移方程：**

        |—> opt(i-1, s - w[i]) + v[i]   (选择当前物品放入背包)
  opt(i, s) = |
        |—> opt(i-1, s - w[i])  (放弃当前物品，不放入背包)

**2.找出边界条件：**

  (1) i < 0    (物品选择完了)
  (2) s == w[i] (当前物品放入背包，背包容量剩余刚好为0)
  (3)一种特殊情况：s < c[i]    (背包余量不足以放下第i件物品了,此时只好放弃当前物品了，状态转移方程必定选第2个转移状态)

**3.递归解决**

```python

def rec_opt(w, v, i, s):
    if i < 0:
        return 0
    elif w[i] == s:
        return v[i]
    elif s < w[i]:
        return rec_opt(w, v, i-1, s)
    else:
        a = rec_opt(w, v, i-1, s - w[i]) + v[i]
        b = rec_opt(w, v, i-1, s)
        return max(a, b)

```

完整代码：
```python

w = [3, 5, 2, 7, 4]
v = [2, 4, 1, 6, 5]
s = 10

def rec_opt(w, v, i, s):
    if i < 0:
        return 0
    elif w[i] == s:
        return v[i]
    elif s < w[i]:
        return rec_opt(w, v, i - 1, s)
    else:
        a = rec_opt(w, v, i - 1, s - w[i]) + v[i]
        b = rec_opt(w, v, i - 1, s)
        return max(a, b)

print(rec_opt(w, v, 4, s))
```

运算结果为9，说明我们能装的物品最大价值为9

**4.变为非递归**

```python
w = [3, 5, 2, 7, 4]
v = [2, 4, 1, 6, 5]
s = 10

def dp_opt(w, v, s):
    opt = [[0 for i in range(s+1)] for j in range(len(w))]
    # 初始化
    for n in range(w[0], s+1):
        opt[0][n] = v[0]
    # 开始循环
    for i in range(1, len(w)):
        for k in range(1, s+1):
            if k == w[i]:
                opt[i][k] = opt[i-1][k-w[i]] + v[i]
            elif k < w[i]:
                opt[i][k] = opt[i-1][k]
            else:
                a = opt[i - 1][k - w[i]] + v[i]
                b = opt[i - 1][k]
                opt[i][k] = max(a, b)
    return opt[len(w)-1][s]

print(dp_opt(w, v, s))
```

非递归运算结果也是9。结果正确。